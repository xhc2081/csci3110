


/**
 * 
 * Q3:
 * A).
 * 		用树形来表示搜索的过程，大概如下：
		 * 							␣ （根节点）
		 * 							|	
		 * 							|
 * 扩展第一层：	         ■ ▲					■ ■
 * 							|					|
 * 							|					|
 * 扩展第二层：	▲●▲		笑脸▲	哭脸▲	■▲■	  ■●■	■无表情    ■哭		....	(这一行都是 ■ ▲扩展出来的)
 * 				▲●■		笑脸■	哭脸■	.....................				(这一行都是 ■ ■扩展出来的)
 * 
 * 后面每层以此类推。。。
 * 
 * 
 * 我们每次搜索的时候，做一个判断，如果扩展到了目标状态，也就是【微笑，哭，无，哭，笑】，这个状态，我们就得到了结果，那么树的深度就是所需要的最小步数。
 * 
 * 
 * 
 * B).
 * 这个肯定是一个最优子结构（optimal-substructure），因为我们第一次到达的某个状态，那么这个状态肯定是最先到达的
 * 因为我们是一层一层的搜索的，这个就相当于一个宽度优先搜索(BFS)的次序。
 * 
 * C)设计细节中，首先这个整个的搜索的过程，我们可以用一个队列(queue)来表示，
 * 		起始的时候，队列里面加上【␣】这一个元素，
 * 		每次我们从队列中取出第一个元素，然后把它扩展，把扩展出来的结果，我们进行判断，如果是和目标状态一样，就说明我们找到了，输出就可以了。
 * 		如果这个元素的长度，大于了5，就说明这个状态是无效的状态，我们把它排除。
 * 		如果队列为空，也就是说我们无法找到目标状态。
 * 
 * E)
 *		伪代码 		
 * 		BFS():											//用BFS算法
 * 			queue.push('␣')								//将初始状态加入队列
 * 			
 * 			while(!queue.isempty)						//判断，如果队列空了，就退出
 * 				start = queue.pop()						//把队列头取出来，作为扩展的起点
 * 				for every condition:					//对于每个扩展条件
 * 					end = start.expand()				//进行扩展操作
 * 					if(end == aim)						//如果扩展出的结果等于目标状态，
 * 						print result and exit.			//就说明找到了，输出并退出
 * 			
 * 			if(queue.isempty)							//如果队列空了，还没找到目标状态，
 * 				print no result							//就说明无结果
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 */








